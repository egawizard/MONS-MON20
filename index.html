<!doctype html>
<html lang="en" class="antialiased">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MON-20 Mint — MONS (Monad Testnet)</title>
  <meta name="description" content="Minting interface and live indexer for MON-20 (MONS) — Monad Testnet" />

  <!-- Tailwind (via CDN for quick deploy) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Ethers.js -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.9.0/dist/ethers.min.js"></script>
  <!-- Chart.js for a simple progress chart -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    .glass { background: rgba(255,255,255,0.04); backdrop-filter: blur(6px); }
  </style>
</head>
<body class="bg-gradient-to-br from-slate-900 to-slate-800 text-slate-100 min-h-screen">
  <div class="max-w-6xl mx-auto p-6">
    <header class="flex items-center justify-between mb-6">
      <div>
        <h1 class="text-3xl font-extrabold">MON-20 Mint — <span class="text-amber-400">$MONS</span></h1>
        <p class="text-sm text-slate-300">Testnet (Monad) • Ready for public launch — created by <a href="https://x.com/ega_2ez4crypto" class="text-amber-300 underline">@ega_2ez4crypto</a></p>
      </div>
      <div class="flex items-center gap-3">
        <div id="networkBadge" class="px-3 py-1 rounded-full glass text-sm">Chain: 10143</div>
        <button id="connectBtn" class="px-4 py-2 bg-amber-500 text-slate-900 font-semibold rounded-lg shadow">Connect Wallet</button>
      </div>
    </header>

    <main class="grid lg:grid-cols-3 gap-6">
      <!-- Left: Mint panel -->
      <section class="p-5 glass rounded-2xl lg:col-span-1">
        <h2 class="font-bold text-lg">Mint MONS</h2>
        <p class="text-sm text-slate-300 mt-1">Max per mint: <span id="maxPerMint">1000</span> • Total supply cap: <span id="supplyCap">21000000</span></p>

        <div class="mt-4">
          <label class="block text-xs text-slate-300">Amount to mint</label>
          <input id="mintAmount" type="number" value="1000" min="1" step="1" class="mt-1 w-full p-3 rounded-lg bg-slate-900 text-white" />
        </div>

        <div class="mt-4">
          <label class="block text-xs text-slate-300">Recipient address (leave empty = your wallet)</label>
          <input id="recipient" type="text" placeholder="0x..." class="mt-1 w-full p-3 rounded-lg bg-slate-900 text-white" />
        </div>

        <div class="mt-4 flex gap-2">
          <button id="mintBtn" class="flex-1 px-4 py-3 bg-amber-500 text-slate-900 rounded-lg font-semibold">Mint</button>
          <button id="estimateBtn" class="px-4 py-3 border border-slate-700 rounded-lg">Estimate</button>
        </div>

        <div id="mintStatus" class="mt-4 text-sm text-slate-300"></div>

        <hr class="my-4 border-slate-700" />

        <h3 class="font-semibold">Quick settings</h3>
        <div class="text-sm text-slate-300 mt-2">
          <label class="block">Contract address (token / inscription contract)</label>
          <input id="contractAddr" placeholder="0x... (paste your token / inscription contract)" class="mt-1 w-full p-2 rounded-lg bg-slate-900 text-white" />
          <label class="block mt-2">Decimals</label>
          <input id="decimals" type="number" value="18" class="mt-1 w-32 p-2 rounded-lg bg-slate-900 text-white" />
          <button id="applySettings" class="mt-3 px-3 py-2 bg-slate-700 rounded">Apply</button>
          <p class="mt-2 text-xs text-amber-200">Note: to send real mint txs the contract address + ABI must accept mint-like calls or you may use a backend operator. This frontend supports calling a standard mutative method named <code>mint</code> or a generic raw transaction payload.</p>
        </div>
      </section>

      <!-- Middle: Indexer / stats -->
      <section class="p-5 glass rounded-2xl lg:col-span-1">
        <h2 class="font-bold text-lg">Live Indexer</h2>
        <div class="mt-3 text-sm text-slate-300">
          <p>Total minted / cap: <strong id="totalMinted">—</strong></p>
          <p>Total holders: <strong id="totalHolders">—</strong></p>
          <p>Top holder: <strong id="topHolder">—</strong></p>
        </div>

        <canvas id="supplyChart" class="mt-4 w-full" style="height:180px"></canvas>

        <h3 class="font-semibold mt-4">Top holders (by balance)</h3>
        <ol id="topHoldersList" class="mt-2 text-sm list-decimal list-inside text-slate-200 max-h-48 overflow-auto"></ol>

        <h3 class="font-semibold mt-4">Live transactions (recent)</h3>
        <div id="liveTxs" class="mt-2 text-xs text-slate-200 max-h-48 overflow-auto"></div>
      </section>

      <!-- Right: Configuration + logs -->
      <section class="p-5 glass rounded-2xl lg:col-span-1">
        <h2 class="font-bold text-lg">Backend / RPC</h2>
        <p class="text-sm text-slate-300">Configured RPC: <code id="rpcUrl">https://testnet-rpc.monad.xyz</code></p>
        <p class="text-sm text-slate-300">Chain ID: <code id="chainIdDisplay">10143</code></p>

        <div class="mt-4">
          <label class="block text-xs text-slate-300">Logs / Console</label>
          <pre id="console" class="mt-2 text-xs bg-slate-900 p-3 rounded max-h-80 overflow-auto"></pre>
        </div>

        <hr class="my-4 border-slate-700" />
        <h3 class="font-semibold">Quick instructions</h3>
        <ol class="text-sm text-slate-300 list-decimal list-inside mt-2">
          <li>Paste your contract address in the settings.</li>
          <li>Click <strong>Connect Wallet</strong> and ensure MetaMask is set to Chain ID 10143 (custom RPC).</li>
          <li>Use the mint form to create a mint transaction (frontend will validate amt ≤1000).</li>
          <li>Indexer will scan Transfer events and display holders & live txs (RPC must allow getLogs).</li>
        </ol>
      </section>
    </main>

    <footer class="mt-8 text-center text-xs text-slate-400">Made with ❤️ — Ready to deploy. Ensure you test thoroughly on Monad testnet before public launch.</footer>
  </div>

<script>
// Config (pre-filled with user's values)
const PRESET = {
  chainId: 10143,
  rpc: 'https://testnet-rpc.monad.xyz',
  tokenTick: 'MONS',
  decimals: 18,
  maxPerMint: 1000,
  supplyCap: '21000000'
};

// Minimal ABI that helps with common ERC20-like tokens + Transfer event
const MIN_ABI = [
  // totalSupply, balanceOf, decimals, Transfer event, name, symbol
  "function totalSupply() view returns (uint256)",
  "function balanceOf(address) view returns (uint256)",
  "function decimals() view returns (uint8)",
  "event Transfer(address indexed from, address indexed to, uint256 value)",
  "function name() view returns (string)",
  "function symbol() view returns (string)",
  // optional mint signature -- many inscriptive systems use different names; attempt common ones
  "function mint(address to, uint256 amount) returns (bool)",
  "function mint(uint256 amount) returns (bool)"
];

let provider = new ethers.providers.JsonRpcProvider(PRESET.rpc);
let walletProvider = null; // metamask/ethers Web3Provider
let signer = null;
let contractAddress = '';
let contract = null;
let decimals = PRESET.decimals;
let supplyCap = BigInt(PRESET.supplyCap) * (BigInt(10) ** BigInt(decimals));

// UI elements
const connectBtn = document.getElementById('connectBtn');
const mintBtn = document.getElementById('mintBtn');
const estimateBtn = document.getElementById('estimateBtn');
const mintAmountInput = document.getElementById('mintAmount');
const recipientInput = document.getElementById('recipient');
const contractInput = document.getElementById('contractAddr');
const decimalsInput = document.getElementById('decimals');
const applyBtn = document.getElementById('applySettings');
const consoleEl = document.getElementById('console');
const totalMintedEl = document.getElementById('totalMinted');
const totalHoldersEl = document.getElementById('totalHolders');
const topHolderEl = document.getElementById('topHolder');
const topHoldersList = document.getElementById('topHoldersList');
const liveTxsEl = document.getElementById('liveTxs');
const mintStatus = document.getElementById('mintStatus');
const maxPerMintEl = document.getElementById('maxPerMint');
const supplyCapEl = document.getElementById('supplyCap');

maxPerMintEl.innerText = PRESET.maxPerMint;
supplyCapEl.innerText = PRESET.supplyCap;

function log(msg) {
  const t = new Date().toISOString();
  consoleEl.textContent = `[${t}] ${msg}\n` + consoleEl.textContent;
}

async function connectWallet() {
  if (window.ethereum) {
    try {
      walletProvider = new ethers.BrowserProvider(window.ethereum);
      await window.ethereum.request({ method: 'eth_requestAccounts' });
      signer = await walletProvider.getSigner();
      const addr = await signer.getAddress();
      connectBtn.innerText = addr.slice(0,6) + '...' + addr.slice(-4);
      log('Wallet connected: ' + addr);
    } catch (e) {
      log('User rejected connection or error: ' + (e.message || e));
    }
  } else {
    log('No web3 wallet found — only read-only mode');
  }
}

connectBtn.addEventListener('click', connectWallet);

applyBtn.addEventListener('click', () => {
  const addr = contractInput.value.trim();
  const dec = parseInt(decimalsInput.value || '18');
  if (addr && ethers.isAddress && !ethers.isAddress(addr)) {
    alert('Invalid contract address');
    return;
  }
  contractAddress = addr;
  decimals = dec;
  // recreate contract if address provided
  if (addr) contract = new ethers.Contract(addr, MIN_ABI, provider);
  log('Settings applied. Contract: ' + (addr || 'none') + ' | decimals: ' + decimals);
  // refresh indexer immediately
  runIndexer().catch(e=>log('Indexer error: '+e));
});

// Mint flow
mintBtn.addEventListener('click', async () => {
  const amt = BigInt(mintAmountInput.value || '0');
  if (amt <= 0n) return alert('Amount must be > 0');
  if (amt > BigInt(PRESET.maxPerMint)) return alert('Amount exceeds per-mint limit of ' + PRESET.maxPerMint);

  if (!signer) return alert('Connect wallet first');
  if (!contractAddress) return alert('Set contract address in settings');

  const recipient = (recipientInput.value.trim() || await signer.getAddress());
  const scaled = amt * (BigInt(10) ** BigInt(decimals));

  try {
    mintStatus.innerText = 'Preparing transaction...';
    // Attempt to call common mint(address,uint256) or mint(uint256) if available
    const contractWithSigner = new ethers.Contract(contractAddress, MIN_ABI, signer);
    let tx;
    // Try mint(to, amount)
    try {
      tx = await contractWithSigner.mint(recipient, scaled);
      log('Sent mint(recipient,amount) tx: ' + tx.hash);
    } catch (e1) {
      log('mint(recipient,amount) failed, trying mint(amount): ' + (e1.message||e1));
      try {
        tx = await contractWithSigner.mint(scaled);
        log('Sent mint(amount) tx: ' + tx.hash);
      } catch (e2) {
        log('Direct mint() calls failed. Falling back to raw transaction attempt. ' + (e2.message||e2));
        // As fallback, let user confirm a raw call data if needed — constructing raw data is risky; so we simply create a generic transaction to the contract with value 0 and data empty to let contract handle it.
        tx = await signer.sendTransaction({ to: contractAddress, value: 0n, data: '0x' });
        log('Sent fallback empty tx: ' + tx.hash);
      }
    }

    mintStatus.innerText = 'Transaction sent. Hash: ' + tx.hash;
    await tx.wait();
    mintStatus.innerText = 'Transaction confirmed: ' + tx.hash;
    log('Tx confirmed: ' + tx.hash);
    // refresh indexer
    await runIndexer();
  } catch (err) {
    log('Mint error: ' + (err?.message || err));
    mintStatus.innerText = 'Mint failed: ' + (err?.message || err);
  }
});

// Estimate (gas/validation)
estimateBtn.addEventListener('click', async () => {
  const amt = BigInt(mintAmountInput.value || '0');
  if (amt <= 0n) return alert('Amount must be > 0');
  if (amt > BigInt(PRESET.maxPerMint)) return alert('Amount exceeds per-mint limit');
  if (!contractAddress) return alert('Set contract address');
  if (!signer) return alert('Connect wallet');
  try {
    const scaled = amt * (BigInt(10) ** BigInt(decimals));
    const c = new ethers.Contract(contractAddress, MIN_ABI, signer);
    let gasEstimate;
    try { gasEstimate = await c.estimateGas.mint(await signer.getAddress(), scaled); }
    catch(e){ gasEstimate = await c.estimateGas.mint(scaled).catch(()=>null); }
    if (gasEstimate) alert('Gas estimate: ' + gasEstimate.toString());
    else alert('Could not estimate gas for mint.');
  } catch (e) { alert('Estimate failed: ' + (e?.message||e)); }
});

// ---------------- Indexer: compute holders/top holders and live txs ----------------
let chart = null;
function setupChart() {
  const ctx = document.getElementById('supplyChart').getContext('2d');
  chart = new Chart(ctx, {
    type: 'doughnut',
    data: { labels: ['Minted', 'Remaining'], datasets: [{ data: [0,100] }] },
    options: { plugins: { legend: { display: true } } }
  });
}
setupChart();

async function runIndexer() {
  if (!contractAddress) {
    log('Indexer: no contract configured.');
    return;
  }
  log('Indexer: scanning events for ' + contractAddress);
  const c = new ethers.Contract(contractAddress, MIN_ABI, provider);
  // Try to fetch totalSupply via contract API
  let totalSupply = null;
  try {
    totalSupply = await c.totalSupply();
  } catch (e) {
    log('totalSupply() call failed: ' + (e.message||e));
  }

  // Now try to get Transfer logs for holder computation. We will fetch logs from block 0 to latest — IMPORTANT: on mainnets this is heavy; on testnet it's usually OK. Consider adding backend indexing for production.
  try {
    const latest = await provider.getBlockNumber();
    // Transfer topic
    const transferTopic = ethers.id('Transfer(address,address,uint256)');
    const logs = await provider.getLogs({ address: contractAddress, fromBlock: 0, toBlock: latest, topics: [transferTopic] });
    log('Fetched ' + logs.length + ' Transfer logs');

    // compute balances
    const balances = new Map();
    for (const l of logs) {
      const parsed = ethers.Interface.from(MIN_ABI).parseLog(l);
      const from = parsed.args.from.toLowerCase();
      const to = parsed.args.to.toLowerCase();
      const val = BigInt(parsed.args.value.toString());
      if (from !== ethers.ZeroAddress) {
        balances.set(from, (balances.get(from) || 0n) - val);
      }
      balances.set(to, (balances.get(to) || 0n) + val);
    }

    // Clean up zero/negative balances
    const cleaned = [];
    for (const [addr, bal] of balances.entries()) {
      if (bal > 0n) cleaned.push({ addr, bal });
    }
    cleaned.sort((a,b)=> (b.bal > a.bal ? 1 : b.bal < a.bal ? -1 : 0));

    // top holders
    const top = cleaned.slice(0,10);
    topHoldersList.innerHTML = '';
    top.forEach((t, idx) => {
      const display = Number(t.bal / (10n ** BigInt(decimals))).toLocaleString();
      const li = document.createElement('li');
      li.textContent = `${t.addr} — ${display}`;
      topHoldersList.appendChild(li);
    });

    totalHoldersEl.innerText = cleaned.length;
    topHolderEl.innerText = (top[0] ? top[0].addr : '—');

    // total minted
    if (totalSupply != null) {
      const human = Number(totalSupply / (10n ** BigInt(decimals))).toLocaleString();
      totalMintedEl.innerText = human;
      const mintedNum = Number(totalSupply / (10n ** BigInt(decimals)));
      const capNum = Number(BigInt(PRESET.supplyCap));
      chart.data.datasets[0].data = [mintedNum, Math.max(0, capNum - mintedNum)];
      chart.update();
    } else {
      // if no totalSupply, compute from balances sum
      const sum = cleaned.reduce((s,t)=> s + Number(t.bal / (10n ** BigInt(decimals))), 0);
      totalMintedEl.innerText = sum.toLocaleString();
      const capNum = Number(BigInt(PRESET.supplyCap));
      chart.data.datasets[0].data = [sum, Math.max(0, capNum - sum)];
      chart.update();
    }

  } catch (err) {
    log('Indexer failure: ' + (err?.message || err));
  }
}

// Live txs: listen for new blocks and show transactions involving the contract
let seenTxs = new Set();
async function startLiveFeed() {
  const p = new ethers.providers.JsonRpcProvider(PRESET.rpc);
  p.on('block', async (bn) => {
    try {
      const block = await p.getBlockWithTransactions(bn);
      for (const tx of block.transactions) {
        if (tx.to && tx.to.toLowerCase() === contractAddress.toLowerCase()) {
          if (seenTxs.has(tx.hash)) continue;
          seenTxs.add(tx.hash);
          const entry = document.createElement('div');
          entry.innerHTML = `<div class='py-1 border-b border-slate-700'>Hash: <a href='#' class='text-amber-300'>${tx.hash}</a><br/>From: ${tx.from}<br/>Value: ${ethers.formatEther(tx.value)} ETH</div>`;
          liveTxsEl.prepend(entry);
          // keep only last 50
          while (liveTxsEl.children.length > 50) liveTxsEl.removeChild(liveTxsEl.lastChild);
        }
      }
    } catch (e) { console.error(e); }
  });
}
startLiveFeed();

// Periodic indexer refresh
setInterval(() => { runIndexer().catch(e=>log('Periodic indexer error: '+e)); }, 30_000);

// initial run
runIndexer().catch(e=>log('Initial indexer error: '+e));

</script>
</body>
</html>
