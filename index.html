<!doctype html>
<html lang="en" class="antialiased">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MON-20 Mint — MONS (Monad Testnet)</title>
  <meta name="description" content="Minting interface and live indexer for MON-20 (MONS) — Monad Testnet" />

  <!-- Tailwind (via CDN for quick deploy) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Ethers.js -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.9.0/dist/ethers.min.js"></script>
  <!-- Chart.js for a simple progress chart -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    .glass { background: rgba(255,255,255,0.04); backdrop-filter: blur(6px); }
  </style>
</head>
<body class="bg-gradient-to-br from-slate-900 to-slate-800 text-slate-100 min-h-screen">
  <div class="max-w-6xl mx-auto p-6">
    <header class="flex items-center justify-between mb-6">
      <div>
        <h1 class="text-3xl font-extrabold">MON-20 Mint — <span class="text-amber-400">$MONS</span></h1>
        <p class="text-sm text-slate-300">Testnet (Monad) • Ready for public launch — created by <a href="https://x.com/ega_2ez4crypto" class="text-amber-300 underline">@ega_2ez4crypto</a></p>
      </div>
      <div class="flex items-center gap-3">
        <div id="networkBadge" class="px-3 py-1 rounded-full glass text-sm">Chain: 10143</div>
        <button id="connectBtn" class="px-4 py-2 bg-amber-500 text-slate-900 font-semibold rounded-lg shadow">Connect Wallet</button>
      </div>
    </header>

    <main class="grid lg:grid-cols-3 gap-6">
      <!-- Left: Mint panel -->
      <section class="p-5 glass rounded-2xl lg:col-span-1">
        <h2 class="font-bold text-lg">Mint MONS</h2>
        <p class="text-sm text-slate-300 mt-1">Max per mint: <span id="maxPerMint">1000</span> • Total supply cap: <span id="supplyCap">21000000</span></p>

        <div class="mt-4">
          <label class="block text-xs text-slate-300">Amount to mint</label>
          <input id="mintAmount" type="number" value="1000" min="1" step="1" class="mt-1 w-full p-3 rounded-lg bg-slate-900 text-white" />
        </div>

        <div class="mt-4">
          <label class="block text-xs text-slate-300">Recipient address (leave empty = your wallet)</label>
          <input id="recipient" type="text" placeholder="0x..." class="mt-1 w-full p-3 rounded-lg bg-slate-900 text-white" />
        </div>

        <div class="mt-4 flex gap-2">
          <button id="mintBtn" class="flex-1 px-4 py-3 bg-amber-500 text-slate-900 rounded-lg font-semibold">Mint</button>
          <button id="estimateBtn" class="px-4 py-3 border border-slate-700 rounded-lg">Estimate</button>
        </div>

        <div id="mintStatus" class="mt-4 text-sm text-slate-300"></div>

        <hr class="my-4 border-slate-700" />

        <h3 class="font-semibold">Quick settings</h3>
        <div class="text-sm text-slate-300 mt-2">
          <label class="block">Contract address (token / inscription contract)</label>
          <input id="contractAddr" placeholder="0x... (paste your token / inscription contract)" class="mt-1 w-full p-2 rounded-lg bg-slate-900 text-white" />
          <label class="block mt-2">Decimals</label>
          <input id="decimals" type="number" value="18" class="mt-1 w-32 p-2 rounded-lg bg-slate-900 text-white" />
          <button id="applySettings" class="mt-3 px-3 py-2 bg-slate-700 rounded">Apply</button>
          <p class="mt-2 text-xs text-amber-200">Note: to send real mint txs the contract address + ABI must accept mint-like calls or you may use a backend operator. This frontend supports calling a standard mutative method named <code>mint</code> or a generic raw transaction payload.</p>
        </div>
      </section>

      <!-- Middle: Indexer / stats -->
      <section class="p-5 glass rounded-2xl lg:col-span-1">
        <h2 class="font-bold text-lg">Live Indexer</h2>
        <div class="mt-3 text-sm text-slate-300">
          <p>Total minted / cap: <strong id="totalMinted">—</strong></p>
          <p>Total holders: <strong id="totalHolders">—</strong></p>
          <p>Top holder: <strong id="topHolder">—</strong></p>
        </div>

        <canvas id="supplyChart" class="mt-4 w-full" style="height:180px"></canvas>

        <h3 class="font-semibold mt-4">Top holders (by balance)</h3>
        <ol id="topHoldersList" class="mt-2 text-sm list-decimal list-inside text-slate-200 max-h-48 overflow-auto"></ol>

        <h3 class="font-semibold mt-4">Live transactions (recent)</h3>
        <div id="liveTxs" class="mt-2 text-xs text-slate-200 max-h-48 overflow-auto"></div>
      </section>

      <!-- Right: Configuration + logs -->
      <section class="p-5 glass rounded-2xl lg:col-span-1">
        <h2 class="font-bold text-lg">Backend / RPC</h2>
        <p class="text-sm text-slate-300">Configured RPC: <code id="rpcUrl">https://testnet-rpc.monad.xyz</code></p>
        <p class="text-sm text-slate-300">Chain ID: <code id="chainIdDisplay">10143</code></p>

        <div class="mt-4">
          <label class="block text-xs text-slate-300">Logs / Console</label>
          <pre id="console" class="mt-2 text-xs bg-slate-900 p-3 rounded max-h-80 overflow-auto"></pre>
        </div>

        <hr class="my-4 border-slate-700" />
        <h3 class="font-semibold">Quick instructions</h3>
        <ol class="text-sm text-slate-300 list-decimal list-inside mt-2">
          <li>Paste your contract address in the settings.</li>
          <li>Click <strong>Connect Wallet</strong> and ensure MetaMask is set to Chain ID 10143 (custom RPC).</li>
          <li>Use the mint form to create a mint transaction (frontend will validate amt ≤1000).</li>
          <li>Indexer will scan Transfer events and display holders & live txs (RPC must allow getLogs).</li>
        </ol>
      </section>
    </main>

    <footer class="mt-8 text-center text-xs text-slate-400">Made with ❤️ — Ready to deploy. Ensure you test thoroughly on Monad testnet before public launch.</footer>
  </div>

<script>
// Updated script: ethers v6 connect + self-transfer inscription mint + block-scanning indexer
const PRESET = {
  chainId: 10143,
  rpc: 'https://testnet-rpc.monad.xyz',
  tokenTick: 'MONS',
  decimals: 18,
  maxPerMint: 1000,
  supplyCap: '21000000'
};

let provider = new ethers.JsonRpcProvider(PRESET.rpc);
let walletProvider = null;
let signer = null;

// UI references
const connectBtn = document.getElementById('connectBtn');
const mintBtn = document.getElementById('mintBtn');
const estimateBtn = document.getElementById('estimateBtn');
const mintAmountInput = document.getElementById('mintAmount');
const recipientInput = document.getElementById('recipient');
const contractInput = document.getElementById('contractAddr');
const decimalsInput = document.getElementById('decimals');
const applyBtn = document.getElementById('applySettings');
const consoleEl = document.getElementById('console');
const totalMintedEl = document.getElementById('totalMinted');
const totalHoldersEl = document.getElementById('totalHolders');
const topHolderEl = document.getElementById('topHolder');
const topHoldersList = document.getElementById('topHoldersList');
const liveTxsEl = document.getElementById('liveTxs');
const mintStatus = document.getElementById('mintStatus');
const maxPerMintEl = document.getElementById('maxPerMint');
const supplyCapEl = document.getElementById('supplyCap');

maxPerMintEl.innerText = PRESET.maxPerMint;
supplyCapEl.innerText = PRESET.supplyCap;

function log(msg) {
  const t = new Date().toISOString();
  consoleEl.textContent = `[${t}] ${msg}\n` + consoleEl.textContent;
}

// ---------------- Wallet connect (ethers v6 correct usage) ----------------
async function connectWallet() {
  if (window.ethereum) {
    try {
      walletProvider = new ethers.BrowserProvider(window.ethereum);
      // request accounts
      await walletProvider.send('eth_requestAccounts', []);
      signer = await walletProvider.getSigner();
      const addr = await signer.getAddress();
      connectBtn.innerText = addr.slice(0,6) + '...' + addr.slice(-4);
      log('Wallet connected: ' + addr);
    } catch (e) {
      log('Connection error: ' + (e.message || e));
      alert('Wallet connection failed: ' + (e.message || e));
    }
  } else {
    log('No Web3 wallet found — read-only mode');
    alert('No Web3 wallet found. Install MetaMask or another Ethereum provider.');
  }
}
connectBtn.addEventListener('click', connectWallet);

applyBtn.addEventListener('click', () => {
  const dec = parseInt(decimalsInput.value || '18');
  PRESET.decimals = dec;
  log('Applied decimals: ' + dec);
  // indexer will pick up new settings
});

// ---------------- Mint via self-transfer inscription ----------------
mintBtn.addEventListener('click', async () => {
  if (!signer) return alert('Connect wallet first');
  const amt = parseInt(mintAmountInput.value || '0');
  if (!amt || amt <= 0) return alert('Amount must be > 0');
  if (amt > PRESET.maxPerMint) return alert('Amount exceeds per-mint limit of ' + PRESET.maxPerMint);

  try {
    const addr = await signer.getAddress();

    const inscription = {
      p: 'mon-20',
      op: 'mint',
      tick: PRESET.tokenTick,
      amt: amt.toString()
    };

    const dataHex = ethers.hexlify(ethers.toUtf8Bytes(JSON.stringify(inscription)));

    mintStatus.innerText = 'Sending mint transaction...';
    const tx = await signer.sendTransaction({ to: addr, value: 0n, data: dataHex });
    log('Mint tx sent: ' + tx.hash);
    mintStatus.innerText = 'Transaction sent: ' + tx.hash;
    await tx.wait();
    mintStatus.innerText = 'Confirmed: ' + tx.hash;
    log('Mint confirmed: ' + tx.hash);

    // immediate UI update
    await runIndexer();
  } catch (e) {
    log('Mint error: ' + (e.message || e));
    mintStatus.innerText = 'Mint failed: ' + (e.message || e);
  }
});

// ---------------- Indexer: scan blocks for self-transfer inscriptions ----------------
// Strategy:
// - Track last scanned block in localStorage to avoid re-scanning entire chain every load.
// - On each run, scan blocks from lastScannedBlock+1 to latest (batched).
// - Parse transactions where tx.from === tx.to and tx.data contains valid UTF-8 JSON
//   with p: "mon-20" and op: "mint" / "deploy" and tick matches token tick.

const BATCH = 200; // blocks per batch (tune for RPC)
let lastScannedKey = 'mons_last_scanned_block';
let lastScanned = parseInt(localStorage.getItem(lastScannedKey) || '0');
let holdersMap = new Map(); // address => minted amount (BigInt of units)
let totalMinted = 0n;

function humanAmount(nBigInt) {
  try {
    const denom = 10n ** BigInt(PRESET.decimals);
    return Number(nBigInt / denom).toLocaleString();
  } catch(e){ return String(nBigInt); }
}

async function runIndexer() {
  try {
    const latest = await provider.getBlockNumber();
    if (lastScanned === 0) {
      // seed start block to latest-5000 for safe default to avoid scanning full chain on first run
      lastScanned = Math.max(0, latest - 5000);
    }
    if (lastScanned >= latest) {
      // nothing to do, but refresh UI
      renderIndexerUI();
      return;
    }

    log(`Indexer scanning blocks ${lastScanned + 1} .. ${latest}`);
    for (let start = lastScanned + 1; start <= latest; start += BATCH) {
      const end = Math.min(latest, start + BATCH - 1);
      // fetch blocks in batch sequentially (could parallelize if needed)
      for (let b = start; b <= end; b++) {
        try {
          const block = await provider.getBlockWithTransactions(b);
          for (const tx of block.transactions) {
            if (!tx.to) continue;
            // self-transfer check (to === from)
            if (tx.to.toLowerCase() !== tx.from.toLowerCase()) continue;
            if (!tx.data || tx.data === '0x') continue;
            // try decode as utf8
            let txt = null;
            try {
              // strip 0x
              const hex = tx.data.startsWith('0x') ? tx.data.slice(2) : tx.data;
              const bytes = ethers.hexToBytes('0x' + hex);
              txt = new TextDecoder().decode(new Uint8Array(bytes));
            } catch (e) {
              // not UTF-8 json
              continue;
            }
            let parsed = null;
            try {
              parsed = JSON.parse(txt);
            } catch (e) {
              continue;
            }
            // check it's our mon-20 inscription
            if (!parsed || !parsed.p) continue;
            const pval = String(parsed.p).toLowerCase();
            if (pval !== 'mon-20') continue;
            const op = String(parsed.op || '').toLowerCase();
            const tick = String(parsed.tick || '').toUpperCase();
            if (tick !== PRESET.tokenTick) continue;

            // handle deploy (optional) or mint
            if (op === 'mint') {
              // amount may be string or number
              const amtRaw = parsed.amt || parsed.amount || '1';
              const amtNum = BigInt(String(amtRaw));
              const scaled = amtNum * (10n ** BigInt(PRESET.decimals));
              // accumulate
              const addr = tx.from.toLowerCase();
              holdersMap.set(addr, (holdersMap.get(addr) || 0n) + scaled);
              totalMinted += scaled;

              // add to live txs
              const entry = document.createElement('div');
              entry.innerHTML = `<div class='py-1 border-b border-slate-700'>Hash: <a href='#' class='text-amber-300'>${tx.hash}</a><br/>From: ${tx.from}<br/>Amt: ${amtNum}</div>`;
              liveTxsEl.prepend(entry);
              while (liveTxsEl.children.length > 100) liveTxsEl.removeChild(liveTxsEl.lastChild);
            } else if (op === 'deploy') {
              log('Found deploy inscription in tx ' + tx.hash);
            }
          }
        } catch (be) {
          console.error('Block fetch error', be);
        }
      }
      // update lastScanned to end
      lastScanned = end;
      localStorage.setItem(lastScannedKey, String(lastScanned));
      renderIndexerUI();
    }
  } catch (err) {
    log('Indexer run error: ' + (err.message || err));
  }
}

function renderIndexerUI() {
  // compute top holders sorted
  const arr = Array.from(holdersMap.entries()).map(([addr, bal]) => ({ addr, bal }));
  arr.sort((a,b)=> (b.bal > a.bal ? 1 : b.bal < a.bal ? -1 : 0));
  topHoldersList.innerHTML = '';
  arr.slice(0,20).forEach(t => {
    const li = document.createElement('li');
    li.textContent = `${t.addr} — ${humanAmount(t.bal)}`;
    topHoldersList.appendChild(li);
  });
  totalHoldersEl.innerText = arr.length;
  topHolderEl.innerText = arr[0] ? arr[0].addr : '—';
  totalMintedEl.innerText = humanAmount(totalMinted);

  // update chart
  try {
    const mintedNum = Number(totalMinted / (10n ** BigInt(PRESET.decimals)));
    const capNum = Number(BigInt(PRESET.supplyCap));
    chart.data.datasets[0].data = [mintedNum, Math.max(0, capNum - mintedNum)];
    chart.update();
  } catch(e){}
}

// start initial indexer run and then periodic
runIndexer().catch(e=>log('Initial indexer error: '+e));
setInterval(()=>{ runIndexer().catch(e=>log('Periodic indexer error: '+e)); }, 30_000);

// Live feed: subscribe to new blocks and show self-transfer inscription txs immediately
provider.on('block', async (bn) => {
  try {
    const block = await provider.getBlockWithTransactions(bn);
    for (const tx of block.transactions) {
      if (!tx.to) continue;
      if (tx.to.toLowerCase() !== tx.from.toLowerCase()) continue;
      if (!tx.data || tx.data === '0x') continue;
      // quick decode attempt
      let txt = null;
      try { txt = new TextDecoder().decode(new Uint8Array(ethers.hexToBytes(tx.data))); } catch(e){ continue; }
      let parsed = null;
      try { parsed = JSON.parse(txt); } catch(e){ continue; }
      if (!parsed || String(parsed.p).toLowerCase() !== 'mon-20') continue;
      if (String(parsed.tick || '').toUpperCase() !== PRESET.tokenTick) continue;
      // show
      const entry = document.createElement('div');
      entry.innerHTML = `<div class='py-1 border-b border-slate-700'>[LIVE] Hash: <a href='#' class='text-amber-300'>${tx.hash}</a><br/>From: ${tx.from}<br/>Data: ${JSON.stringify(parsed)}</div>`;
      liveTxsEl.prepend(entry);
      while (liveTxsEl.children.length > 100) liveTxsEl.removeChild(liveTxsEl.lastChild);
      // update holders summary quickly
      try {
        if (parsed.op && String(parsed.op).toLowerCase() === 'mint') {
          const amtNum = BigInt(String(parsed.amt || parsed.amount || '1')) * (10n ** BigInt(PRESET.decimals));
          const addr = tx.from.toLowerCase();
          holdersMap.set(addr, (holdersMap.get(addr) || 0n) + amtNum);
          totalMinted += amtNum;
          renderIndexerUI();
        }
      } catch(e){ }
    }
  } catch(e) { console.error(e); }
});

// Chart setup (reuse existing)
function setupChart() {
  const ctx = document.getElementById('supplyChart').getContext('2d');
  chart = new Chart(ctx, {
    type: 'doughnut',
    data: { labels: ['Minted', 'Remaining'], datasets: [{ data: [0,100] }] },
    options: { plugins: { legend: { display: true } } }
  });
}
setupChart();

</script>
</body>
</html>
